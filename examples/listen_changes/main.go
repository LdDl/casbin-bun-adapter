package main

import (
	"crypto/tls"
	"database/sql"
	"fmt"
	"log"
	"time"

	casbinbunadapter "github.com/LdDl/casbin-bun-adapter"
	"github.com/casbin/casbin/v2"
	"github.com/uptrace/bun"
	"github.com/uptrace/bun/dialect/pgdialect"
	"github.com/uptrace/bun/driver/pgdriver"
)

func main() {
	/* Just database connection parameters */
	dbHost := "localhost"
	dbPort := 5432
	dbUser := "postgres"
	dbPassword := "postgres"
	dbName := "postgres"
	var tlsConf *tls.Config = nil
	appName := "example_custom_names"

	/* Initialize driver connector and get *bun.DB object */
	sqldb := sql.OpenDB(pgdriver.NewConnector(
		pgdriver.WithAddr(fmt.Sprintf("%s:%d", dbHost, dbPort)),
		pgdriver.WithUser(dbUser),
		pgdriver.WithPassword(dbPassword),
		pgdriver.WithDatabase(dbName),
		pgdriver.WithTLSConfig(tlsConf),
		pgdriver.WithApplicationName(appName),
	))
	dbConn := bun.NewDB(sqldb, pgdialect.New())
	defer func(db *bun.DB) {
		err := db.Close() // Make sure that you finalize connection to the database
		if err != nil {
			log.Println("Error on closing database connection", err)
		}
	}(dbConn)

	/* Let's asume having custom defined rules. SQL is:
	CREATE TABLE dev.potato_policies (
		id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
		pt varchar(2) DEFAULT 'p'::character varying NOT NULL,
		v0 varchar(256) NULL,
		haha varchar(256) NULL,
		v2 varchar(256) NULL,
		v3 varchar(256) NULL,
		v4 varchar(256) NULL,
		v5 varchar(256) NULL,
		CONSTRAINT potato_policies_pk PRIMARY KEY (id),
		CONSTRAINT potato_policies_unique UNIQUE NULLS NOT DISTINCT (pt, v0, haha, v2, v3, v4, v5)
	);
	*/
	/* Assuming we will have RBAC with deny, let's populate table with some data. SQL is:
		INSERT INTO dev.potato_policies (id,pt,v0,haha,v2,v3,v4,v5) VALUES
		 (1,'p','alice','data1','read','allow',NULL,NULL),
		 (2,'p','bob','data2','write','allow',NULL,NULL),
		 (3,'p','data2_admin','data2','read','allow',NULL,NULL),
		 (4,'p','data2_admin','data2','write','allow',NULL,NULL),
		 (6,'g','alice','data2_admin',NULL,NULL,NULL,NULL);
	  SELECT SETVAL('dev.potato_policies_id_seq', (SELECT MAX(id) + 1 FROM dev.potato_policies));
	*/

	/* Define custom matcher */
	matcher := casbinbunadapter.MatcherOptions{
		SchemaName: "dev",
		TableName:  "potato_policies",
		ID:         "id",
		PType:      "pt",
		V0:         "v0",
		V1:         "haha",
		V2:         "",
		V3:         "v3",
		V4:         "v4",
		V5:         "v5",
	}
	trigger := casbinbunadapter.TriggerOptions{
		Name:               "casbin_call_trigger",
		FunctionName:       "update_policies_table",
		FunctionSchemaName: "public",
		FunctionReplace:    true,
		TriggerReplace:     true, // Works only for PostgreSQL 14.x and above
		ChannelName:        "CASBIN_UPDATE_MESSAGE",
	}
	/* Initialize adapter */
	adapter := casbinbunadapter.NewBunAdapter(
		dbConn,
		casbinbunadapter.WithMatcherOptions(matcher),
		casbinbunadapter.WithTriggerOptions(trigger),
	)
	/* Build trigger */
	err := adapter.PrepareTrigger()
	if err != nil {
		log.Println("Error on preparing trigger", err)
		return
	}

	enforcer, err := casbin.NewSyncedEnforcer("examples/custom_names/rbac_deny.conf", adapter)
	if err != nil {
		log.Println("Error on creating new casbin enforcer", err)
		return
	}

	/* Check permissions */
	found, err := enforcer.Enforce("alice", "data1", "read") // Should be TRUE
	if err != nil {
		log.Println("Error on enforcing", err)
		return
	}
	fmt.Println("Has access?", found)

	found, err = enforcer.Enforce("alice", "data2", "write") // Should be FALSE due deny rule with ID '5'
	if err != nil {
		log.Println("Error on enforcing", err)
		return
	}
	fmt.Println("Has access?", found)

	/* Start listening to database table updated. Make sure it has been started on prepare enforcer */
	// When data in table changes (due INSERT/UPDATE operation) enforcer rules would be updated too
	// Be careful when making application logic: make sure that you not going to use AutoSave/SavePolicy in casbin along with listening to database updates since it could cause infinity recursion
	errCh := make(chan error)
	go func(enf *casbin.SyncedEnforcer, errCh chan error) {
		err = adapter.StartUpdatesListening(enf)
		if err != nil {
			log.Println("Error on database listener", err)
			errCh <- err
		}
	}(enforcer, errCh)

	/* Check delete trigger */
	time.Sleep(100 * time.Millisecond)
	_, err = dbConn.Exec("delete from dev.potato_policies where id = 5;")
	if err != nil {
		log.Println("Error on executing SQL query", err)
		return
	}

	time.Sleep(100 * time.Millisecond)
	found, err = enforcer.Enforce("alice", "data2", "write") // Now should be TRUE due removing rule with ID '5'
	if err != nil {
		log.Println("Error on enforcing", err)
		return
	}
	fmt.Println("Has access after DENY rule delete?", found)

	/* Check insert trigger */
	time.Sleep(100 * time.Millisecond)
	_, err = dbConn.Exec("INSERT INTO dev.potato_policies (id,pt,v0,haha,v2,v3,v4,v5) VALUES (5,'p','alice','data2','write','deny',NULL,NULL);")
	if err != nil {
		log.Println("Error on executing SQL query", err)
		return
	}

	time.Sleep(100 * time.Millisecond)
	found, err = enforcer.Enforce("alice", "data2", "write") // Now should be FALSE due deny rule with ID '5'
	if err != nil {
		log.Println("Error on enforcing", err)
		return
	}
	fmt.Println("Has access after DENY rule insert?", found)

	/* Check update trigger */
	// Attention: since UPDATE method is implemented as cascade of Add/Remove policis functions then if something goes wrong in adding policies stage then previous removed policies won't roll back
	time.Sleep(100 * time.Millisecond)
	_, err = dbConn.Exec("update dev.potato_policies set v3 = 'allow' where id = 5;")
	if err != nil {
		log.Println("Error on executing SQL query", err)
		return
	}
	time.Sleep(100 * time.Millisecond)
	found, err = enforcer.Enforce("alice", "data2", "write") // Now should be TRUE due rule with ID '5' update to 'allow'
	if err != nil {
		log.Println("Error on enforcing", err)
		return
	}
	fmt.Println("Has access after DENY rule update (allow)?", found)
	time.Sleep(100 * time.Millisecond)
	_, err = dbConn.Exec("update dev.potato_policies set v3 = 'deny' where id = 5;")
	if err != nil {
		log.Println("Error on executing SQL query", err)
		return
	}
	time.Sleep(100 * time.Millisecond)
	found, err = enforcer.Enforce("alice", "data2", "write") // Now should be FALSE due rule with ID '5' update to 'false'
	if err != nil {
		log.Println("Error on enforcing", err)
		return
	}
	fmt.Println("Has access after DENY rule update (deny)?", found)

	select {
	case e := <-errCh:
		log.Println("Err", e)
		return
	}
}
