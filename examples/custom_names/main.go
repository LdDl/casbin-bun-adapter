package main

import (
	"crypto/tls"
	"database/sql"
	"fmt"
	"log"

	casbinbunadapter "github.com/LdDl/casbin-bun-adapter"
	"github.com/casbin/casbin/v2"
	"github.com/uptrace/bun"
	"github.com/uptrace/bun/dialect/pgdialect"
	"github.com/uptrace/bun/driver/pgdriver"
)

func main() {
	/* Just database connection parameters */
	dbHost := "localhost"
	dbPort := 5432
	dbUser := "postgres"
	dbPassword := "postgres"
	dbName := "postgres"
	var tlsConf *tls.Config = nil
	appName := "example_custom_names"

	/* Initialize driver connector and get *bun.DB object */
	sqldb := sql.OpenDB(pgdriver.NewConnector(
		pgdriver.WithAddr(fmt.Sprintf("%s:%d", dbHost, dbPort)),
		pgdriver.WithUser(dbUser),
		pgdriver.WithPassword(dbPassword),
		pgdriver.WithDatabase(dbName),
		pgdriver.WithTLSConfig(tlsConf),
		pgdriver.WithApplicationName(appName),
	))
	dbConn := bun.NewDB(sqldb, pgdialect.New())
	defer func(db *bun.DB) {
		err := db.Close() // Make sure that you finalize connection to the database
		if err != nil {
			log.Println("Error on closing database connection", err)
		}
	}(dbConn)

	/* Let's asume having custom defined rules. SQL is:
	CREATE TABLE dev.potato_policies (
		id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
		pt varchar(2) DEFAULT 'p'::character varying NOT NULL,
		v0 varchar(256) NULL,
		haha varchar(256) NULL,
		v2 varchar(256) NULL,
		v3 varchar(256) NULL,
		v4 varchar(256) NULL,
		v5 varchar(256) NULL,
		CONSTRAINT potato_policies_pk PRIMARY KEY (id),
		CONSTRAINT potato_policies_unique UNIQUE NULLS NOT DISTINCT (pt, v0, haha, v2, v3, v4, v5)
	);
	*/
	/* Assuming we will have RBAC with deny, let's populate table with some data. SQL is:
		INSERT INTO dev.potato_policies (id,pt,v0,haha,v2,v3,v4,v5) VALUES
		 (1,'p','alice','data1','read','allow',NULL,NULL),
		 (2,'p','bob','data2','write','allow',NULL,NULL),
		 (3,'p','data2_admin','data2','read','allow',NULL,NULL),
		 (4,'p','data2_admin','data2','write','allow',NULL,NULL),
		 (5,'p','alice','data2','write','deny',NULL,NULL),
		 (6,'g','alice','data2_admin',NULL,NULL,NULL,NULL);
	  SELECT SETVAL('dev.potato_policies_id_seq', (SELECT MAX(id) + 1 FROM dev.potato_policies));
	*/

	/* Define custom matcher */
	matcher := casbinbunadapter.MatcherOptions{
		SchemaName: "dev",
		TableName:  "potato_policies",
		ID:         "id",
		PType:      "pt",
		V0:         "v0",
		V1:         "haha",
		V2:         "",
		V3:         "v3",
		V4:         "v4",
		V5:         "v5",
	}
	/* Initialize adapter */
	adapter := casbinbunadapter.NewBunAdapter(dbConn, casbinbunadapter.WithMatcherOptions(matcher))
	enforcer, err := casbin.NewEnforcer("examples/custom_names/rbac_deny.conf", adapter)
	if err != nil {
		log.Println("Error on creating new casbin enforcer", err)
		return
	}

	// Load policies from database
	err = enforcer.LoadPolicy()
	if err != nil {
		log.Println("Error on loading policies into the enforcer", err)
		return
	}

	/* Check permissions */
	found, err := enforcer.Enforce("alice", "data1", "read") // Should be TRUE
	if err != nil {
		log.Println("Error on enforcing", err)
		return
	}
	fmt.Println("Has access?", found)

	found, err = enforcer.Enforce("alice", "data2", "write") // Should be FALSE due deny rule with ID '5'
	if err != nil {
		log.Println("Error on enforcing", err)
		return
	}
	fmt.Println("Has access?", found)

	/* Save policies to database */
	err = enforcer.SavePolicy()
	if err != nil {
		log.Println("Error on saving enforcer rules to the database", err)
		return
	}
}
